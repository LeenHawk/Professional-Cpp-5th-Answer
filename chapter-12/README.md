# chapter-12 利用模块编写泛型编码

## 12-1

编写一个 KeyValuePair 类模块，其中包含两个模板类型参数：键和值。该类应该有两个私有数据成员来存储一个键和一个值。提供一个接受键和值的构造函数，并添加适当的 getter 和 setter。通过在 main() 函数中创建几个实例来测试新编写的类，并尝试类模板参数推断。

## 12-2

练习 12-1 中的 KeyValuePair 类模板支持其键和值模板类型参数的所有类型的数据类型。例如，下面的示例使用 std::string 作为键和值的类型来实例化类模板。

```c++
KeyValuePair<std::string, std::string> kv { "John Doe", "New York" };
```

然而，使用 const char\* 作为类型将会导致 const char\* 类型的数据成员，但这不是期望的结果。

为 const char\* 键和值编写类模板特化，将给定字符串转换为 std::string。

## 12-3

从练习 12-1 中获取解决方案，进行适当的更改，只允许整数类型作为键的类型，并且只允许浮点类型作为值的类型。

## 12-4

编写一个函数模板 concat()，它带有两个模板类型参数和两个函数参数 t1 和 t2。该函数首先将 t1 和 t2 转换为一个字符串，然后返回这两个字符串的连接。对于这个联系，只关注数字的输入，比如支持 std::to_string() 的整数和浮点数。创建并使用正确的概念，以确保函数模板的用户不会试图将其用于不支持的类型。尝试在不使用 template 关键字的情况下编写函数模板。

## 12-5

练习 12-4 中的 concat() 函数模板只支持数值类型。在本练习中，请修改 12-4 中的解决方案，使其在 2 个参数都是字符串、1 个参数是字符类型，而另 1 个参数是字符串类型时都能工作。

## 12-6

使用本章前面的原始 Find() 函数模板，并在类型 T 上添加一个适当的约束。
